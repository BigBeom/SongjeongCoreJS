# 1. 데이터 타입

## 1-1 데이터 타입의 종류

- 기본형
    - 숫자, 문자열, 불리언, null, undefined, 심볼(ES6에 추가)
    - 값이 담긴 주솟값을 바로 복제
- 참조형
    - 객체, 배열, 함수, 날짜, 정규표현식
    - ES6추가된 Map, WakMap, Set, WeakSet 등
    - 값이 담긴 주솟값들로 이루어진 **묶음을 가리키는 주솟값**을 복제

## 1-2 데이터 타입에 관한 배경지식

### 1-2-1 메모리와 데이터

- 컴퓨터는 모든 데이터를 0과 1로 기억. 이 하나를 비트. 각 비트는 고유한 식별자를 통해 위치를 확인
- 적절한 비트를 한 단위로 묶어 검색시간을 줄이고 표현할 데이터 개수도 확보. 낭비되지 않게 8개비트를 1바이트로 지정
- C/C++, 자바 정적타입언어는 메모리 낭비 최소화를 위해 데이터 타입별로 2byte,4byte등으로 나눔
- JS는 메모리 용량이 커진 시대에 태어남. 8바이트를 기본확보
- 각비트는 고유한 식별자 지님→ 바이트 단위의 식별자=**메모리주솟값**

### 1-2-2 식별자와 변수

- 변수: 변할 수 있는 데이터
- 식별자: 데이터를 식별하는데 사용하는 이름. 변수명

## 1-3 변수 선언과 데이터 할당

### 1-3-1 변수 선언

예시

```python
var a;
```

→ “변할 수 있는 데이터를 만든다. 이 데이터의 식별자는 a로 한다.”

변수: 변경 가능한 데이터가 담길 수 있는 공간 또는 그릇

위 코드를 입력하면

메모리가 비어있는 임의의 주소에

메모리 공간의 이름(식별자)를 a로 지정한 것.

값은 빈공간

### 1-3-2 데이터 할당

- 위,아래 JS는 같은 동작을 수행
- abc를 직접 저장한 것은 아님

- 데이터 할당의 전체 흐름

- 변수 영역에 값을 직접 대입하지 않고 한 단계 더 거치는 이유:
    - 데이터 변환을 자유롭게 할 수 있게 함
    - 메모리를 더욱 효율적으로 관리하기 위함(JS는 기본 8바이트나 쓴다)
    - 아래 예시 정확히 이해하기;

## 1-4 기본형 데이터와 참조형 데이터

### 1-4-1 불변값

- 변수, 상수를 구분 짓는 변경 가능성의 대상은 변수 영역 메모리
- 불변성 여부를 구분할 때의 변경 가능성의 대상의 데이터 영역 메모리
- **기본형 데이터**는 모두 불변값
- 예시1

```python
var a = 'abc';
a = a + 'def';
```

abc가 abcdef가 되는 것이 아닌 새로운 abcdef를 만들어 그 주소를 변수a에 저장

- 예시2

```python
var b = 5;
var c = 5;
b = 7;
```

c는 데이터 영역에서 ‘5’의 주소를 같이 재활용. 데이터 영역의 5를 7로 바꾸는게 아닌 새로운 7을 생성 또는 기존 에있다면 재활용하는 것

### 1-4-2 가변값

- 참조형은 대부분 가변
- but, 설정에 따라 변경 불가능한 경우, 아예 불변값으로 활용하는 방안도 있음(나중에..)

- 차이점: 객체의 변수**(프로퍼티)** 영역이 별도 존재

위 코드에

```python
obj1.a = 2;
```

를 추가하면

- 중첩 객체

→ 여기까지 즉, **참조형은 변수영역에 새롭게 변수명을 지정하여 데이터 영역의 주소를 계속 참조함**

- obj.arr[1]을 검색하고자 하면 메모리에서는 다음과 같은 검색 과정을 거친다.
- 
- 다음과 같은 재할당 명령을 내린다면?

```python
obj.arr = 'str';
```

참조 카운트가 0인 메모리 주소는 **가비지 컬렉터(GC)**의 수거대상이 됨.

### 1-4-3 변수 복사 비교 (다시보기)

1. 객체의 프로퍼티 변경 시

2. 객체 자체를 변경했을 때

## 1-5 불변 객체

### 1-5-1 불변 객체를 만드는 간단한 방법

- 값으로 전달받은 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우에 필요함
- 예시

개선 1단계

→ user와 user2는 서로다른 객체이므로 변경 전,후 비교가능

개선 2단계

- 대상 객체의 프로퍼티 개수에 상관없이 모든 프로퍼티를 복사하는 함수(얕은 복사)
- 객체 복사, 수정
- copyObject함수를 사용하면 user 객체는 곧 불변 객체

1-5-2 얕은 복사와 깊은 복사

- 얕은 복사: 바로 아래 단계의 값만 복사
- 깊은 복사: 내부의 모든 값들을 하나하나 찾아서 전부 복사

어떤 객체를 복사할 때 객체 내부의 모든 값을 복사해서 완전히 새로운 데이터를 만들고자 할 때

- 객체의 프로퍼티 중에서 그 값이 기본형 데이터일 경우에는 그대로 복사
- 참조형 데이터는 다시 그 내부의 프로퍼티들을 복사
- JSON 활용한 간단한 깊은 복사

## 1-6 undifined와 null

- undifined
    - 명시적 지정 가능, JS 엔진이 자동 부여
    - 자동 부여 경우 3가지
        1. 값을 대입하지 않은 변수. 즉 **데이터 영역**의 메모리 주소를 지정하지 않은 식별자에 접근할 때
        2. 객체 내부의 존재하지 않는 프로퍼티(객체의 변수)에 접근하려고 할 때
        3. return 문이 없거나 호출되지 않는 함수의 실행 결과
    
    차이점
    
    - 명시적으로 부여한 경우 undefined는 그 자체로 값
        - 하나의 값으로 동작, 프로퍼티나 배열의 요소는 고유의 키값(프로퍼티 이름)이 실존하게 되어 **순회의 대상이 될 수 있다.**
    - JS엔진이 자동부여
        - 해당 프로퍼티 내지 배열의 키값(인덱스) 자체가 존재하지 않음을 의미.
    
    ⇒ 값으로써 어딘가에 할당된 실존하는 데이터 vs 문자 그대로 값이 없음을 나타냄
    
- null
    - 위 혼동을 피하려면 ‘비어있음’을 나타낼 땐 null을 사용하자.
    - null 타입은 객체임을 주의